# RxJs

RxJs, also known as Reactive Extensions for JavaScript, is a library for reactive programming using Observables, which is a design pattern for handling asynchronous events in a more manageable way. RxJs is a popular library used in modern web applications, especially in Angular.

The main concept in RxJs is the Observable pattern, which is a representation of a sequence of events that can be observed over time. An Observable can emit any number of events, and these events can be of any type, including data, errors, and completion signals.

RxJs provides a rich set of operators to transform, filter, and combine Observables. These operators can be used to perform complex data manipulations, such as filtering data based on certain criteria, merging multiple streams of data into one, and transforming data into a different format.

One of the key benefits of using RxJs is that it makes it easier to handle asynchronous events in a more predictable and manageable way. By using Observables, developers can write code that reacts to events as they occur, rather than waiting for them to happen and then reacting.

In addition, RxJs provides a range of tools for handling errors and managing concurrency. It also integrates well with other popular libraries and frameworks, such as React and Redux.

Overall, RxJs is a powerful tool for handling asynchronous events in modern web applications. Its rich set of operators and flexible design make it a popular choice for developers looking to build reactive and scalable applications.

### ****Essential Concepts in RxJs****

- **Observable**
- **Observer**
- **Subscription**
- **Operators**
- **Subject**
- **Schedulers**

### The essential concepts in RxJS which solve async event management are

- **Observable : represents the idea of an invokable collection of future values or events.**
    - Observable is a concept in programming that represents a stream of values over time. It is commonly used in reactive programming and allows you to handle asynchronous operations, such as fetching data from an API or handling user input, in a more organized and manageable way.
    - Now, let's create an example where we simulate fetching data from an API using an Observable:
        
        ```jsx
        // Import the necessary modules from RxJS
        import { Observable } from 'rxjs';
        
        // Create an Observable
        const dataObservable = new Observable(observer => {
          // Simulate API call or asynchronous operation
          setTimeout(() => {
            const data = [1, 2, 3, 4, 5];
            observer.next(data); // Emit the data to the observer
            observer.complete(); // Signal the completion of the Observable
          }, 2000);
        });
        
        // Subscribe to the Observable
        dataObservable.subscribe(data => {
          console.log('Received data:', data);
        }, error => {
          console.error('An error occurred:', error);
        }, () => {
          console.log('Observable completed');
        });
        
        ```
        
    - In the above code, we create an Observable called `dataObservable` using the `Observable` class from RxJS. Inside the Observable, we simulate an API call or an asynchronous operation using `setTimeout`. After 2 seconds, we emit the data using `observer.next(data)` to send the values to any subscribed observers.
    - To subscribe to the Observable, we use the `subscribe` method. It takes three optional callback functions: `next`, `error`, and `complete`. In our example, the `next` function logs the received data, the `error` function logs any error that occurs, and the `complete` function logs a message when the Observable completes.
    - When you run this code, it will output:
        
        ```
        Received data: [1, 2, 3, 4, 5]
        Observable completed
        
        ```
        
    - This demonstrates the basic usage of Observable. You can perform various operations on Observables, such as filtering, transforming, combining, and merging them, using operators provided by the RxJS library. These operators allow you to manipulate the stream of data emitted by the Observable and perform complex asynchronous operations in a declarative and composable manner.
- **Observer : is a collection of callbacks that knows how to listen to values delivered by the Observable.**
    - Observer is an interface or a set of callback functions that receives values emitted by an Observable. It listens for events or data emitted by the Observable and performs actions based on those events.
    - Let's illustrate the concept of an Observer with an example in JavaScript:
        
        ```jsx
        // Define an Observer object
        const myObserver = {
          next: (value) => {
            console.log('Received value:', value);
          },
          error: (error) => {
            console.error('An error occurred:', error);
          },
          complete: () => {
            console.log('Observable completed');
          }
        };
        
        // Simulate an Observable that emits data
        const dataObservable = new Observable(observer => {
          observer.next(1);
          observer.next(2);
          observer.next(3);
          observer.complete();
        });
        
        // Subscribe the Observer to the Observable
        dataObservable.subscribe(myObserver);
        
        ```
        
    - In this example, we define an Observer object called `myObserver`. It contains three functions: `next`, `error`, and `complete`.
        - The `next` function is called whenever a value is emitted by the Observable. In this case, it logs the received value to the console.
        - The `error` function is called if an error occurs during the execution of the Observable. It logs the error to the console.
        - The `complete` function is called when the Observable completes, indicating that it has finished emitting all the values. It logs a completion message to the console.
    - Next, we create an Observable called `dataObservable` that emits three values: 1, 2, and 3, and then completes. We subscribe the `myObserver` to this Observable using the `subscribe` method.
        - When you run this code, it will output:
            
            ```
            Received value: 1
            Received value: 2
            Received value: 3
            Observable completed
            
            ```
            
    - The Observer receives each emitted value through the `next` function and logs them to the console. Once the Observable completes, the `complete` function of the Observer is called.
    - Observers allow you to define the logic that should be executed when certain events occur within an Observable. They provide a way to handle the data emitted by Observables and respond accordingly, whether it's processing the data, updating the UI, or triggering other actions in your application.
- **Subscription : represents the execution of an Observable, is primarily useful for cancelling the execution.**
    - Subscription represents the connection between an Observer and an Observable. It allows the Observer to receive values emitted by the Observable and provides a way to unsubscribe and stop receiving further values.
    - Let's illustrate the concept of a Subscription with an example in JavaScript:
        
        ```jsx
        // Import the necessary modules from RxJS
        import { Observable } from 'rxjs';
        
        // Create an Observable
        const dataObservable = new Observable(observer => {
          const intervalId = setInterval(() => {
            observer.next('Value emitted');
          }, 1000);
        
          // Return a cleanup function to stop emitting values
          return () => {
            clearInterval(intervalId);
          };
        });
        
        // Subscribe to the Observable and get a Subscription object
        const subscription = dataObservable.subscribe(value => {
          console.log(value);
        });
        
        // Unsubscribe after 5 seconds
        setTimeout(() => {
          subscription.unsubscribe();
          console.log('Unsubscribed');
        }, 5000);
        
        ```
        
    - In this example, we create an Observable called `dataObservable` that emits the string `'Value emitted'` every second using `setInterval`. Inside the Observable, we also define a cleanup function that stops the interval by calling `clearInterval` when the subscription is unsubscribed.
        - Next, we subscribe to the Observable using the `subscribe` method and store the returned Subscription object in the variable `subscription`. The `subscribe` method takes a callback function as an argument, which logs the received value to the console.
    - After 5 seconds, we call `subscription.unsubscribe()` to unsubscribe from the Observable and stop receiving further values. We also log the message `'Unsubscribed'` to the console.
    - When you run this code, it will output:
        
        ```
        Value emitted
        Value emitted
        Value emitted
        Value emitted
        Value emitted
        Unsubscribed
        
        ```
        
    - The Observable emits the value `'Value emitted'` every second, and the Observer receives and logs it to the console. After 5 seconds, the subscription is unsubscribed, and no further values are emitted.
    - Subscriptions are important for managing the lifecycle of Observables. They allow you to control when to start and stop receiving values from an Observable. By unsubscribing, you free up resources and prevent memory leaks, especially when dealing with long-running Observables or when you no longer need to listen to the emitted values.
- **Operators : are pure functions that enable a functional programming style of dealing with collections with operations like `[map](https://rxjs.dev/api/index/function/map)`, `[filter](https://rxjs.dev/api/index/function/filter)`, `[concat](https://rxjs.dev/api/index/function/concat)`, `[reduce](https://rxjs.dev/api/index/function/reduce)`, etc.**
    - Operators are functions used to manipulate and transform the data emitted by Observables. They allow you to perform a wide range of operations on the stream of values, such as filtering, mapping, combining, or aggregating them, in a declarative and composable manner.
    - Let's illustrate the concept of operators with an example in JavaScript using the RxJS library:
        
        ```jsx
        // Import the necessary modules from RxJS
        import { of } from 'rxjs';
        import { map, filter, take } from 'rxjs/operators';
        
        // Create an Observable
        const numbersObservable = of(1, 2, 3, 4, 5);
        
        // Apply operators to transform the data
        numbersObservable
          .pipe(
            filter(number => number % 2 === 0), // Filter even numbers
            map(number => number * 2), // Multiply each number by 2
            take(3) // Take only the first 3 numbers
          )
          .subscribe(result => {
            console.log(result);
          });
        
        ```
        
    - In this example, we start by creating an Observable called `numbersObservable` using the `[of](https://rxjs.dev/api/index/function/of)` function from RxJS. It emits the numbers 1, 2, 3, 4, and 5.
        
        > We then use operators to transform the data emitted by the Observable:
        > 
        - The `[filter](https://rxjs.dev/api/index/function/filter)` operator filters the numbers and only allows even numbers to pass through. In this case, it checks if the number is divisible by 2 using the modulo operator.
        - The `[map](https://rxjs.dev/api/index/function/map)` operator multiplies each number by 2, effectively doubling them.
        - The `[take](https://rxjs.dev/api/operators/take)` operator limits the number of values to be emitted. In this case, it takes only the first 3 values.
    
    Finally, we subscribe to the transformed Observable and log the result to the console.
    
    - When you run this code, it will output:
        
        ```
        4
        8
        
        ```
        
    - The original Observable emits the numbers 1, 2, 3, 4, and 5. However, by applying the operators, we filter out the odd numbers, double the remaining even numbers, and take only the first three values. As a result, only the numbers 2 and 4 pass through the transformations and are logged to the console.
    - Operators in reactive programming provide a powerful way to transform and manipulate data streams. They allow you to perform complex operations on the emitted values while maintaining a concise and readable code structure. RxJS provides a rich set of operators that you can use to compose and chain together to achieve the desired data transformations in your reactive applications.
- **Subject : is equivalent to an EventEmitter, and the only way of multicasting a value or event to multiple Observers.**
    - Subject is a special type of Observable that allows both multicasting and subscribing to it. It acts as both an Observable and an Observer, allowing values to be emitted and received by multiple subscribers.
    - Let's illustrate the concept of a Subject with an example in JavaScript using the RxJS library:
        
        ```jsx
        // Import the necessary modules from RxJS
        import { Subject } from 'rxjs';
        
        // Create a Subject
        const mySubject = new Subject();
        
        // Subscribe to the Subject
        mySubject.subscribe(value => {
          console.log('Subscriber 1 received:', value);
        });
        
        // Emit values through the Subject
        mySubject.next('Hello');
        mySubject.next('World');
        
        // Subscribe another observer to the Subject
        mySubject.subscribe(value => {
          console.log('Subscriber 2 received:', value);
        });
        
        // Emit another value
        mySubject.next('Another value');
        
        ```
        
    - In this example, we start by creating a Subject called `mySubject` using the `Subject` class from RxJS.
        - We then subscribe the first observer to the Subject using the `subscribe` method. The observer logs the received value to the console.
        - Next, we emit values through the Subject using the `next` method. The values `'Hello'` and `'World'` are emitted, and the first observer receives and logs both values.
        - After that, we subscribe another observer to the Subject. This observer logs the received value to the console as well.
        - Finally, we emit another value through the Subject using `next`, and both observers receive and log the value `'Another value'`.
    - When you run this code, it will output:
        
        ```
        Subscriber 1 received: Hello
        Subscriber 1 received: World
        Subscriber 2 received: World
        Subscriber 1 received: Another value
        Subscriber 2 received: Another value
        
        ```
        
    - The Subject allows multiple subscribers to receive the emitted values. In this case, both `Subscriber 1` and `Subscriber 2` subscribe to the Subject. When values are emitted through the Subject using `next`, all the subscribers receive and process those values.
    - Subjects are useful when you want to broadcast or multicast values to multiple subscribers. They provide a way to centralize and share a single stream of values among multiple parts of your application. Additionally, Subjects can act as event emitters, allowing you to trigger and propagate events within your reactive system.
- **Schedulers : are centralized dispatchers to control concurrency, allowing us to coordinate when computation happens on e.g. `setTimeout` or `requestAnimationFrame` or others.**
    - Schedulers provide control over when and how operations are executed within an Observable stream. They allow you to specify the timing and execution context for subscribing, emitting values, and handling events.
    - Schedulers are commonly used to manage concurrency, handle asynchronous operations, and introduce delays or timers within reactive programming. Let's illustrate the concept of schedulers with an example in JavaScript using the RxJS library:
        
        ```jsx
        // Import the necessary modules from RxJS
        import { of, asyncScheduler } from 'rxjs';
        import { observeOn } from 'rxjs/operators';
        
        // Create an Observable
        const numbersObservable = of(1, 2, 3, 4, 5);
        
        // Use a scheduler to control the timing of emissions
        numbersObservable
          .pipe(observeOn(asyncScheduler))
          .subscribe(value => {
            console.log(value);
          });
        
        ```
        
    - In this example, we start by creating an Observable called `numbersObservable` using the `of` function from RxJS. It emits the numbers 1, 2, 3, 4, and 5.
        - We then use the `observeOn` operator to specify a scheduler for the Observable. In this case, we use the `asyncScheduler` provided by RxJS. The `asyncScheduler` executes the emissions asynchronously, allowing for non-blocking operations.
        - Finally, we subscribe to the Observable and log the emitted values to the console.
    - When you run this code, it will output:
        
        ```
        1
        2
        3
        4
        5
        
        ```
        
    
    - The `asyncScheduler` ensures that the emissions from the Observable are handled asynchronously, allowing the execution to be non-blocking. This is particularly useful when dealing with operations that involve delays, timers, or asynchronous tasks.
    - Schedulers in reactive programming provide control over when and how operations are executed within an Observable stream. They allow you to specify the timing and execution context, enabling you to handle concurrency, asynchronous operations, and timing-related tasks in a flexible and controlled manner. RxJS provides several built-in schedulers, such as `asyncScheduler`, `queueScheduler`, and `animationFrameScheduler`, each tailored to different use cases and execution contexts.

### ****Subjects :-****

- A Subject is a special type of Observable which shares a single execution path among observers.
- You can think of this as a single speaker talking at a microphone in a room full of people. Their message (the subject) is being delivered to many (multicast) people (the observers) at once. This is the basis of **multicasting**. Typical observables would be comparable to a 1 on 1 conversation.
- There are 4 variants of subjects:
    - **[Subject](https://www.learnrxjs.io/learn-rxjs/subjects/subject)** - No initial value or replay behavior.
    - **[AsyncSubject](https://www.learnrxjs.io/learn-rxjs/subjects/asyncsubject)** - Emits latest value to observers upon completion.
    - **[BehaviorSubject**](https://www.learnrxjs.io/learn-rxjs/subjects/behaviorsubject) - Requires an initial value and emits its current value (last emitted item) to new subscribers.
    - **[ReplaySubject**](https://www.learnrxjs.io/learn-rxjs/subjects/replaysubject) - Emits specified number of last emitted values (a replay) to new subscribers.

### FROM EVENT() :-

- `fromEvent` function is used to create an Observable from events emitted by a DOM element or a Node.js EventEmitter. It allows you to work with event-based asynchronous operations in a reactive manner. Here's an explanation of how `fromEvent` works:
- Syntax:
    
    ```jsx
    fromEvent<T>(target: EventTargetLike, eventName: string, options?: EventListenerOptions | ((...args: any[]) => T), resultSelector?: (...args: any[]) => T): Observable<T>
    ```
    
- Parameters:
    - `target`: The target object that emits the events. It can be a DOM element or a Node.js EventEmitter.
    - `eventName`: The name of the event to listen to.
    - `options` (optional): Additional options for event listening, such as `{ capture: true }` for capturing events during the event propagation phase.
    - `resultSelector` (optional): A function that maps the emitted event arguments to a specific value.
- Example usage:
    
    ```jsx
    import { fromEvent } from 'rxjs';
    
    // Example 1: Listening to a button click event
    const button = document.querySelector('button');
    
    const click$ = fromEvent(button, 'click');
    click$.subscribe(() => console.log('Button clicked'));
    
    // Example 2: Listening to a custom EventEmitter event
    import { EventEmitter } from 'events';
    
    const emitter = new EventEmitter();
    
    const customEvent$ = fromEvent(emitter, 'customEvent');
    customEvent$.subscribe((data) => console.log('Custom event:', data));
    
    // Emitting a custom event
    emitter.emit('customEvent', { message: 'Hello, RxJS!' });
    
    ```
    

- In the first example, `fromEvent` is used to create an Observable (`click$`) that emits values whenever the `click` event occurs on a button element. The subscription then logs a message to the console whenever the button is clicked.
- In the second example, `fromEvent` is used to create an Observable (`customEvent$`) that listens to a custom event (`customEvent`) emitted by a Node.js EventEmitter (`emitter`). When the custom event is emitted, the subscription logs the event data to the console.
- The `fromEvent` function is a powerful tool for working with event-driven programming paradigms and integrating event-based operations into your RxJS workflows.

### INTERVAL & TIMER

`interval` and `timer` functions are used to create Observables that emit values over time at specified intervals. They are often used for handling timed operations and creating periodic data streams. Let's explore each function:

1. `interval`:
    - The `interval` function creates an Observable that emits incremental numbers at a specified time interval.
    - It starts emitting values immediately upon subscription and continues indefinitely.
    - The emitted values represent the elapsed time since the subscription, with the first value being 0, the second value being 1, and so on.
    - The interval between emitted values is constant.
    - Syntax:
        
        ```jsx
        interval(period: number): Observable<number>
        
        ```
        
    - Example usage:
        
        ```jsx
        import { interval } from 'rxjs';
        
        // Emitting a value every second
        const source$ = interval(1000);
        source$.subscribe((value) => console.log(value)); // Output: 0, 1, 2, 3, ...
        
        ```
        
    
    In this example, the `interval(1000)` Observable emits values every 1000 milliseconds (1 second), and the subscription logs the emitted values (`0`, `1`, `2`, `3`, ...) to the console.
    
2. `timer`:
    - The `timer` function creates an Observable that emits a single value after a specified delay, and optionally repeats that emission periodically at a specified interval.
    - It allows you to control when the first value is emitted and the interval between subsequent emissions.
    - You can specify the delay in milliseconds before the first value emission and an optional interval for subsequent emissions.
    - If no interval is provided, `timer` emits only a single value and completes.
    - Syntax:
        
        ```
        timer(dueTime: number | Date = 0, periodOrScheduler?: number | SchedulerLike, scheduler?: SchedulerLike): Observable<number>
        ```
        
    - Example usage:
        
        ```
        import { timer } from 'rxjs';
        
        // Emitting a value after 2 seconds
        const source$ = timer(2000);
        source$.subscribe(() => console.log('Timer completed')); // Output: Timer completed
        
        // Emitting a value after 1 second and then repeating every 2 seconds
        const source2$ = timer(1000, 2000);
        source2$.subscribe((value) => console.log(value)); // Output: 0, 1, 2, 3, ...
        ```
        
    - In the first example, the `timer(2000)` Observable emits a single value after a delay of 2000 milliseconds (2 seconds), and the subscription logs the completion message to the console.
    - In the second example, the `timer(1000, 2000)` Observable emits the first value after a delay of 1000 milliseconds (1 second) and then emits subsequent values every 2000 milliseconds (2 seconds). The subscription logs the emitted values (`0`, `1`, `2`, `3`, ...) to the console.

Both `interval` and `timer` are useful for handling timed operations and creating periodic data streams in RxJS. They allow you to work with time-based events and incorporate time-dependent behaviors into your reactive programming workflows.

### SWITCHMAP

`switchMap` operator is used to transform the values emitted by an Observable into another Observable. It cancels the previous inner Observable and switches to a new inner Observable whenever a new value is emitted by the source Observable. Let's dive into the details of `switchMap`:

- Syntax:
    
    ```jsx
    switchMap(project: function(value: T, index: number): ObservableInput<R>, resultSelector?: function(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number): any): OperatorFunction<T, R>
    ```
    
- Parameters:
    - `project`: A function that takes the emitted value from the source Observable and returns an inner Observable.
    - `resultSelector` (optional): A function that combines the most recent values from the source and inner Observables and returns the result.
- Behavior:
    - Whenever a new value is emitted by the source Observable, `switchMap` cancels the previous inner Observable (unsubscribe) and subscribes to a new inner Observable returned by the `project` function.
    - The values emitted by the new inner Observable become the values emitted by the resulting Observable.
- If the source Observable completes or errors, the inner Observable is unsubscribed.
- Example usage:
    
    ```jsx
    import { of } from 'rxjs';
    import { switchMap } from 'rxjs/operators';
    
    // Emitting values and switching to an inner Observable
    const source$ = of(1, 2, 3);
    
    const result$ = source$.pipe(
      switchMap((value) => of(value * 2))
    );
    
    result$.subscribe((value) => console.log(value)); // Output: 2, 4, 6
    
    ```
    
- In this example, the `source$` Observable emits values `1`, `2`, and `3`. The `switchMap` operator transforms each emitted value by multiplying it by 2 using the `of(value * 2)` Observable. Since `switchMap` switches to the new inner Observable for each emitted value, the result is a new Observable (`result$`) that emits the transformed values `2`, `4`, and `6`. The subscription then logs these values to the console.
- `switchMap` is commonly used in scenarios where you want to map values to inner Observables, but only emit the values from the latest inner Observable while canceling any ongoing inner Observables from previous emissions. It's useful for handling scenarios like HTTP requests, where you want to cancel previous requests and only work with the response from the latest request.
- It's worth noting that there are other related operators in RxJS, such as `mergeMap`, `concatMap`, and `exhaustMap`, which have similar functionality but handle the inner Observables in different ways.

### OF & FROM

`of` and `from` functions are used to create Observables from various types of data sources. They allow you to work with synchronous and asynchronous data streams. Let's explore each function:

1. `of`:
    - The `of` function is used to create an Observable that emits a sequence of values synchronously.
    - It can accept a variable number of arguments or an array of values to emit.
    - After emitting all the values, the `of` Observable completes.
    - Syntax:
        
        ```
        of<T>(...values: T[]): Observable<T>
        
        ```
        
    - Example usage:
        
        ```
        import { of } from 'rxjs';
        
        const source$ = of(1, 2, 3, 4, 5);
        source$.subscribe((value) => console.log(value)); // Output: 1, 2, 3, 4, 5
        
        ```
        
    
    In this example, the `of(1, 2, 3, 4, 5)` Observable emits the values `1`, `2`, `3`, `4`, and `5` synchronously. The subscription logs each emitted value to the console.
    
2. `from`:
    - The `from` function is used to create an Observable from various types of data sources, such as arrays, iterables, promises, or other Observables.
    - It converts the data source into an Observable that emits each value one by one.
    - It can handle both synchronous and asynchronous data sources.
    - Syntax:
        
        ```jsx
        from<T>(input: ObservableInput<T>): Observable<T>
        
        ```
        
    - Example usage:
        
        ```jsx
        import { from } from 'rxjs';
        
        // Creating an Observable from an array
        const arraySource$ = from([1, 2, 3, 4, 5]);
        arraySource$.subscribe((value) => console.log(value)); // Output: 1, 2, 3, 4, 5
        
        // Creating an Observable from a promise
        const promiseSource$ = from(fetch('<https://api.example.com/data>'));
        promiseSource$.subscribe((response) => console.log(response)); // Output: The response object
        
        // Creating an Observable from another Observable
        const observableSource$ = from(anotherObservable);
        observableSource$.subscribe((value) => console.log(value)); // Output: Values emitted by anotherObservable
        
        ```
        
    - In this example, `from` is used to create Observables from different data sources. The `from([1, 2, 3, 4, 5])` Observable emits the values of the array. The `from(fetch('<https://api.example.com/data>'))` Observable emits the response object from the HTTP request. The `from(anotherObservable)` Observable emits the values emitted by another Observable.
    - The `of` and `from` functions are essential for creating Observables from different data sources and integrating them into your RxJS workflows. They provide a convenient way to work with synchronous and asynchronous data streams and enable you to transform and combine data from various sources using the rich set of operators provided by RxJS.

### toARRAY

`toArray` operator is used to accumulate all the emitted values from an Observable into an array, and then emit that array as a single value. It waits for the source Observable to complete before emitting the accumulated array. Let's explore how `toArray` works:

- Syntax:
    
    ```jsx
    toArray<T>(): OperatorFunction<T, T[]>
    
    ```
    
- Example usage:
    
    ```jsx
    import { of } from 'rxjs';
    import { toArray } from 'rxjs/operators';
    
    const source$ = of(1, 2, 3, 4, 5);
    
    source$
      .pipe(toArray())
      .subscribe((array) => console.log(array)); // Output: [1, 2, 3, 4, 5]
    
    ```
    
- In this example, the `source$` Observable emits the values `1`, `2`, `3`, `4`, and `5`. The `toArray` operator accumulates these values into an array. After the source Observable completes, it emits the accumulated array (`[1, 2, 3, 4, 5]`) as a single value. The subscription then logs the emitted array to the console.
- The `toArray` operator is useful when you want to collect all the emitted values from an Observable and process them as a batch or as a single entity. It allows you to transform a stream of values into a single emitted value, which can be helpful in scenarios where you need to work with the entire set of values at once.
- It's important to note that `toArray` waits for the source Observable to complete before emitting the accumulated array. If the source Observable doesn't complete, the `toArray` operator will not emit any value. So, make sure that the source Observable completes or use operators like `take` or `takeUntil` to control the completion of the source Observable if necessary.

### CUSTOM OBSERVABLE

- In RxJS, you can create custom Observables by implementing the `Observable` interface. Creating a custom Observable allows you to define the behavior of the Observable and control how values are emitted over time. Here's an example of creating a custom Observable:
    
    ```jsx
    import { Observable, Observer } from 'rxjs';
    
    class CustomObservable<T> implements Observable<T> {
      constructor(private producer: (observer: Observer<T>) => void) {}
    
      subscribe(observer: Observer<T>) {
        this.producer(observer);
      }
    }
    
    ```
    
- In this example, we create a `CustomObservable` class that implements the `Observable` interface. The constructor takes a `producer` function as a parameter, which is responsible for defining the behavior of the Observable. The `producer` function is given an `observer` parameter, which is an instance of the `Observer` interface. The `producer` function can emit values to the observer by calling its `next` method, handle errors with the `error` method, and signal completion using the `complete` method.
- Here's an example of using the custom Observable:
    
    ```jsx
    const customObservable = new CustomObservable<number>((observer) => {
      observer.next(1);
      observer.next(2);
      observer.next(3);
      observer.complete();
    });
    
    customObservable.subscribe({
      next: (value) => console.log(value),
      complete: () => console.log('Completed'),
    });
    
    ```
    
- In this usage example, we create an instance of `CustomObservable` and provide a `producer` function that emits values `1`, `2`, and `3` to the observer using the `next` method. Finally, we signal completion by calling the `complete` method. We subscribe to the custom Observable and provide an object with `next` and `complete` functions as the observer. The emitted values are logged to the console, and the completion message is logged when the Observable completes.
- By creating custom Observables, you have the flexibility to define complex behavior, integrate with external data sources or APIs, and control how values are emitted over time. It allows you to customize the behavior of your data streams and build powerful reactive systems tailored to your specific needs.

### MAP

`map` operator is used to transform the values emitted by an Observable by applying a mapping function to each emitted value. It creates a new Observable that emits the transformed values. The `map` operator is similar to the `Array.map` method in JavaScript. Let's explore how `map` works:

- Syntax:
    
    ```jsx
    map<T, R>(project: (value: T, index: number) => R): OperatorFunction<T, R>
    ```
    

Parameters:

- `project`: A function that takes the emitted value from the source Observable and returns a transformed value.
- Example usage:
    
    ```jsx
    import { of } from 'rxjs';
    import { map } from 'rxjs/operators';
    
    const source$ = of(1, 2, 3, 4, 5);
    
    source$
      .pipe(map((value) => value * 2))
      .subscribe((result) => console.log(result)); // Output: 2, 4, 6, 8, 10
    ```
    
- In this example, the `source$` Observable emits values `1`, `2`, `3`, `4`, and `5`. The `map` operator applies the transformation function `(value) => value * 2` to each emitted value, multiplying it by 2. The resulting Observable emits the transformed values `2`, `4`, `6`, `8`, and `10`. The subscription logs each transformed value to the console.
- The `map` operator is commonly used for data transformation in RxJS. It allows you to modify the emitted values, convert them to different types, or apply any desired logic. You can chain multiple `map` operators together to perform a sequence of transformations on the values.
- It's important to note that the `map` operator does not modify the source Observable directly. Instead, it creates a new Observable that emits the transformed values. The original source Observable remains unchanged.
- By using the `map` operator, you can easily transform and manipulate the values emitted by Observables, enabling you to perform various data processing and transformation tasks in a reactive and composable manner.

### PLUCK

`pluck` operator is used to extract a specific property value from the objects emitted by an Observable. It allows you to access nested properties using dot notation or array notation. Let's explore how `pluck` works:

- Syntax:
    
    ```jsx
    pluck<T, R>(...properties: string[]): OperatorFunction<T, R>
    ```
    

Parameters:

- `...properties`: The property names or keys of the values you want to extract. You can provide multiple properties to access nested properties.
- Example usage:
    
    ```jsx
    import { of } from 'rxjs';
    import { pluck } from 'rxjs/operators';
    
    const source$ = of(
      { name: 'John', age: 30, address: { city: 'New York', country: 'USA' } },
      { name: 'Alice', age: 25, address: { city: 'London', country: 'UK' } },
      { name: 'Bob', age: 35, address: { city: 'Sydney', country: 'Australia' } }
    );
    
    source$
      .pipe(pluck('name'))
      .subscribe((name) => console.log(name)); // Output: 'John', 'Alice', 'Bob'
    
    source$
      .pipe(pluck('address', 'city'))
      .subscribe((city) => console.log(city)); // Output: 'New York', 'London', 'Sydney'
    ```
    
- In the first example, the `source$` Observable emits objects with properties `name`, `age`, and `address`. The `pluck('name')` operator extracts the value of the `name` property from each object and emits only the extracted name values. The subscription logs the extracted names `'John'`, `'Alice'`, and `'Bob'` to the console.
- In the second example, the `pluck('address', 'city')` operator extracts the value of the `city` property from the nested `address` property of each object. It accesses the nested property using dot notation. The subscription logs the extracted city values `'New York'`, `'London'`, and `'Sydney'` to the console.
- The `pluck` operator simplifies the process of accessing specific properties from emitted objects, especially when dealing with nested data structures. It helps extract only the required values, enabling you to focus on the relevant data for further processing or analysis.
- Note: If the emitted value is not an object or if the specified property is not present, the `pluck` operator will emit `undefined` for that value. You can handle such cases by combining `pluck` with other operators like `filter` or using optional chaining (`?.`) to avoid errors.

### FILTER

`filter` operator is used to selectively emit values from an Observable based on a provided predicate function. It filters out values that do not satisfy the specified condition, allowing you to selectively include or exclude values in the resulting Observable. Let's explore how `filter` works:

- Syntax:
    
    ```
    filter<T>(predicate: (value: T, index: number) => boolean, thisArg?: any): OperatorFunction<T, T>
    
    ```
    

Parameters:

- `predicate`: A function that takes an emitted value and its index and returns a boolean value indicating whether the value should be emitted (`true`) or filtered out (`false`).
- `thisArg` (optional): The context (`this`) to which the predicate function is bound.
- Example usage:
    
    ```
    import { of } from 'rxjs';
    import { filter } from 'rxjs/operators';
    
    const source$ = of(1, 2, 3, 4, 5);
    
    source$
      .pipe(filter((value) => value % 2 === 0))
      .subscribe((evenValue) => console.log(evenValue)); // Output: 2, 4
    
    source$
      .pipe(filter((value) => value > 3))
      .subscribe((greaterThanThree) => console.log(greaterThanThree)); // Output: 4, 5
    
    ```
    
- In the first example, the `source$` Observable emits values `1`, `2`, `3`, `4`, and `5`. The `filter((value) => value % 2 === 0)` operator filters out the values that are not divisible by 2, allowing only the even values (`2` and `4`) to be emitted. The subscription then logs each even value to the console.
- In the second example, the `filter((value) => value > 3)` operator filters out values that are not greater than 3, resulting in only the values `4` and `5` being emitted. The subscription logs each value greater than 3 to the console.
- The `filter` operator provides a powerful mechanism for selecting and including only the desired values from an Observable based on a specific condition. It allows you to effectively handle data streams by focusing on the relevant values that meet the specified criteria.
- By combining the `filter` operator with other operators and building complex pipelines, you can create precise and efficient data processing workflows in your RxJS applications.

### TAP

`tap` operator is used to perform side effects or execute additional logic for each value emitted by an Observable, without modifying the emitted values themselves. It allows you to inspect or perform actions based on the emitted values, such as logging, making additional calls, or updating external state. Let's explore how `tap` works:

- Syntax:
    
    ```jsx
    tap<T>(
      next?: (value: T) => void,
      error?: (error: any) => void,
      complete?: () => void
    ): MonoTypeOperatorFunction<T>
    ```
    

Parameters:

- `next` (optional): A function that is called for each value emitted by the source Observable. It receives the emitted value as a parameter.
- `error` (optional): A function that is called if the source Observable emits an error. It receives the error as a parameter.
- `complete` (optional): A function that is called if the source Observable completes.
- Example usage:
    
    ```jsx
    import { of } from 'rxjs';
    import { tap } from 'rxjs/operators';
    
    const source$ = of(1, 2, 3);
    
    source$
      .pipe(
        tap((value) => console.log('Received value:', value)),
        tap(
          (value) => console.log('Performing additional action with value:', value),
          (error) => console.error('Error occurred:', error),
          () => console.log('Source completed')
        )
      )
      .subscribe((value) => console.log('Next value:', value));
    
    // Output:
    // Received value: 1
    // Performing additional action with value: 1
    // Next value: 1
    // Received value: 2
    // Performing additional action with value: 2
    // Next value: 2
    // Received value: 3
    // Performing additional action with value: 3
    // Next value: 3
    // Source completed
    ```
    
- In this example, the `source$` Observable emits values `1`, `2`, and `3`. The `tap` operator is used twice in the pipeline:
- The first `tap` operator logs the received value to the console without modifying it.
- The second `tap` operator logs the received value and performs an additional action. It also handles errors and logs the completion of the source Observable.
- The subscription receives the values emitted by the source Observable, and the `tap` operators execute their respective logic for each emitted value. The modified values are not affected by the `tap` operator; it simply allows you to observe and perform side effects.
- The `tap` operator is commonly used for debugging, logging, and performing additional actions that do not modify the emitted values. It is a useful tool for understanding the behavior of an Observable and its emitted values throughout the pipeline.
- It's important to note that the `tap` operator does not affect the values or the flow of the pipeline. If you need to modify the values, you should use other operators such as `map`, `filter`, or `reduce`.

### TAKE

`take` operator is used to emit a specified number of values from the beginning of an Observable and then complete the Observable. It allows you to control the number of emitted values, limiting the stream to a specific count. Let's explore how `take` works:

- Syntax:
    
    ```jsx
    take<T>(count: number): OperatorFunction<T, T>
    ```
    

Parameters:

- `count`: The number of values to emit from the source Observable before completing.
- Example usage:
    
    ```jsx
    import { interval } from 'rxjs';
    import { take } from 'rxjs/operators';
    
    const source$ = interval(1000);
    
    source$
      .pipe(take(3))
      .subscribe((value) => console.log(value));
    
    // Output:
    // 0
    // 1
    // 2
    ```
    
- In this example, the `source$` Observable emits incremental values every 1000 milliseconds (1 second) using the `interval` operator. The `take(3)` operator limits the stream to emit only the first three values emitted by the source Observable. The subscription logs the first three values (`0`, `1`, and `2`) to the console.
- The `take` operator is useful when you want to limit the number of emitted values in an Observable, such as fetching a specific number of items from an API response or processing only a subset of a data stream. It allows you to control the length of the Observable and terminate it after a specified count of values has been emitted.
- By combining the `take` operator with other operators, you can build complex pipelines and control the flow of data in your RxJS applications.

### RETRY

`retry` operator is used to automatically re-subscribe to the source Observable when it encounters an error. It allows you to retry the emission of values from the source Observable a certain number of times or indefinitely until a successful emission occurs or the maximum number of retries is reached. Let's explore how `retry` works:

- Syntax:
    
    ```jsx
    retry<T>(count: number = -1): MonoTypeOperatorFunction<T>
    ```
    

Parameters:

- `count` (optional): The number of retry attempts. By default, it is set to `1`, which means it retries indefinitely until a successful emission or an error occurs.
- Example usage:
    
    ```jsx
    import { of, throwError } from 'rxjs';
    import { mergeMap, retry } from 'rxjs/operators';
    
    let retryAttempts = 0;
    
    const source$ = of('data');
    
    source$
      .pipe(
        mergeMap(() => {
          if (retryAttempts < 3) {
            retryAttempts++;
            return throwError('Error occurred');
          }
          return of('success');
        }),
        retry(3)
      )
      .subscribe(
        (value) => console.log(value),
        (error) => console.error(error)
      );
    
    // Output:
    // Error occurred
    // Error occurred
    // Error occurred
    // success
    
    ```
    
- In this example, the `source$` Observable emits the value `'data'`. The `mergeMap` operator is used to simulate an asynchronous operation that throws an error on the first three attempts and emits `'success'` on the fourth attempt. The `retry(3)` operator is applied after `mergeMap` to retry the emission up to three times.
- As a result, the subscription encounters an error on the first three attempts and logs the error message `'Error occurred'`. On the fourth attempt, the `'success'` value is emitted, and it is logged to the console.
- The `retry` operator allows you to automatically re-subscribe to the source Observable in case of errors, providing resilience to transient failures and allowing for potential recovery. It is commonly used when working with network requests or any scenario where you want to retry an operation.
- It's important to use `retry` carefully and consider the implications, as retrying indefinitely can result in an endless loop. You can set a maximum number of retries or use other operators like `retryWhen` to introduce more control and custom retry logic based on specific conditions.
- By utilizing the `retry` operator, you can build robust and resilient reactive applications that handle errors and recover from temporary failures in a flexible and controlled manner.

### DEBOUNCETIME & DISTINCTUNTILCHANGED

In RxJS, `debounceTime` and `distinctUntilChanged` are operators used to control the emissions of values from an Observable based on specific conditions. Let's explore each operator:

1. `debounceTime`:
    - The `debounceTime` operator is used to emit a value from an Observable only after a specified duration of silence has passed since the last emission.
    - It delays the emission of values and discards values emitted within the specified duration if new values are emitted before that duration elapses.
    - This operator is often used to handle scenarios such as search input throttling or reducing the frequency of event emissions.
    - Syntax:
        
        ```jsx
        debounceTime<T>(dueTime: number, scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T>
        ```
        
    
    Parameters:
    
    - `dueTime`: The duration in milliseconds to wait after the last value emission before emitting the value.
    - `scheduler` (optional): The scheduler to use for managing the timing of emissions.
    - Example usage:
        
        ```jsx
        import { fromEvent } from 'rxjs';
        import { debounceTime, map } from 'rxjs/operators';
        
        const inputElement = document.getElementById('input');
        
        fromEvent(inputElement, 'input')
          .pipe(
            map((event) => event.target.value),
            debounceTime(300)
          )
          .subscribe((value) => console.log(value));
        ```
        
    
    In this example, the `fromEvent` function is used to create an Observable that emits values whenever the `input` event occurs on the `inputElement`. The emitted values are mapped to the input value using `map`. The `debounceTime(300)` operator is applied to delay the emissions and emit the value only after 300 milliseconds of silence since the last emission. The subscription logs the debounced value to the console.
    
2. `distinctUntilChanged`:
    - The `distinctUntilChanged` operator is used to filter out consecutive duplicate values emitted by an Observable, allowing only distinct values to be emitted.
    - It compares the current value with the previous value and emits the value only if it is different from the previous value.
    - This operator is often used to avoid emitting duplicate values in scenarios where consecutive emissions of the same value are not desired.
    - Syntax:
        
        ```jsx
        distinctUntilChanged<T>(compare?: (x: T, y: T) => boolean): MonoTypeOperatorFunction<T>
        ```
        
    
    Parameters:
    
    - `compare` (optional): A function that compares two values and returns a boolean indicating whether they are considered equal. If not provided, a strict equality check (`===`) is used.
    - Example usage:
        
        ```jsx
        import { of } from 'rxjs';
        import { distinctUntilChanged } from 'rxjs/operators';
        
        const source$ = of(1, 2, 2, 3, 3, 3, 2, 1);
        
        source$
          .pipe(distinctUntilChanged())
          .subscribe((value) => console.log(value));
        
        // Output: 1, 2, 3, 2, 1
        ```
        
    - In this example, the `source$` Observable emits values `1, 2, 2, 3, 3, 3, 2, 1`. The `distinctUntilChanged()` operator is applied to filter out consecutive duplicate values. Only distinct values are emitted, resulting in the output `1, 2, 3, 2, 1`.
    - The `debounceTime` and `distinctUntilChanged` operators are powerful tools for controlling the timing and uniqueness of emitted values in RxJS. They allow you to fine-tune the behavior of your Observables and handle specific scenarios where rate limiting, throttling, or avoiding duplicate emissions is required.

### CONCATMAP

`concatMap` operator is used to transform the values emitted by an Observable into inner Observables, and then concatenate and flatten their emissions in a serialized manner. It maintains the order of emission and ensures that each inner Observable completes before the next one starts. Let's explore how `concatMap` works:

- Syntax:
    
    ```jsx
    concatMap<T, R>(
      project: (value: T, index: number) => ObservableInput<R>,
      resultSelector?: (outerValue: T, innerValue: R, outerIndex: number, innerIndex: number) => any
    ): OperatorFunction<T, R>
    ```
    

Parameters:

- `project`: A function that takes the emitted value from the source Observable and returns an inner Observable.
- `resultSelector` (optional): A function that combines the values emitted by the source and inner Observables and returns the result.
- Example usage:
    
    ```jsx
    import { of } from 'rxjs';
    import { concatMap } from 'rxjs/operators';
    
    const source$ = of(1, 2, 3);
    
    source$
      .pipe(
        concatMap((value) => of(value * 2))
      )
      .subscribe((result) => console.log(result)); // Output: 2, 4, 6
    ```
    
- In this example, the `source$` Observable emits values `1`, `2`, and `3`. The `concatMap` operator transforms each emitted value by multiplying it by 2 using the `of(value * 2)` Observable. The resulting Observable emits the transformed values `2`, `4`, and `6`. The subscription then logs each transformed value to the console.
- The key aspect of `concatMap` is that it maintains the order of emission and ensures that the inner Observables are subscribed to and completed in a serialized manner. It waits for each inner Observable to complete before subscribing to the next one, effectively concatenating their emissions.
- It's worth noting that there are other similar operators in RxJS, such as `mergeMap`, `switchMap`, and `exhaustMap`, which handle the inner Observables in different ways and have different behaviors regarding concurrency and completion.
- By using the `concatMap` operator, you can transform and flatten nested Observables in a serialized manner, ensuring that each inner Observable completes before proceeding to the next one. This can be particularly useful for scenarios such as sequential API requests or ordered data transformations.

### SUBJECT

`Subject` is a special type of Observable that allows both multicasting and acting as an Observer. It can be used to manually emit values and subscribe to them, making it a powerful tool for creating custom data streams and facilitating communication between different parts of an application. Let's explore how `Subject` works:

1. Creating a Subject:
You can create a Subject instance using the `Subject` class or its variants, such as `BehaviorSubject`, `ReplaySubject`, or `AsyncSubject`.
    - Example:
        
        ```jsx
        import { Subject } from 'rxjs';
        
        const subject = new Subject<number>();
        ```
        
    
    In this example, a new `Subject` instance is created to handle values of type `number`. The `Subject` is initially empty and doesn't have any emitted values.
    
2. Emitting values:
You can emit values to the Subject manually using its `next` method. This allows you to trigger the emission of values from any part of your code.
    - Example:
        
        ```jsx
        subject.next(1);
        subject.next(2);
        subject.next(3);
        ```
        
    
    In this example, values `1`, `2`, and `3` are emitted to the `subject` using its `next` method.
    
3. Subscribing to a Subject:
You can subscribe to a Subject to receive its emitted values, similar to subscribing to a regular Observable.
    - Example:
        
        ```jsx
        subject.subscribe((value) => console.log(value));
        ```
        
    
    In this example, a subscription is created to the `subject`, and a callback function is provided to handle the emitted values. When new values are emitted, the callback function will be invoked, and the emitted value will be logged to the console.
    
4. Completing a Subject:
You can manually complete a Subject by calling its `complete` method. This will notify all its subscribers that no more values will be emitted.
    - Example:
        
        ```
        subject.complete();
        
        ```
        
    
    In this example, the `complete` method is called on the `subject`, indicating that no more values will be emitted. The subscribers will receive the completion notification, and the Subject will be considered completed.
    
    - Subjects provide a way to create custom Observable-like entities that can act as both Observables and Observers. They allow you to manually emit values, multicast them to multiple subscribers, and manage communication between different parts of your application. Subjects are commonly used in scenarios where you need more control over the emissions and subscriptions, such as event handling, inter-component communication, or implementing custom operators.
    - It's important to note that Subjects are not purely functional like regular Observables since they have mutable state and rely on side effects. Care should be taken when using Subjects to ensure proper encapsulation and avoid unintended side effects.
    - RxJS provides different variations of Subjects (e.g., BehaviorSubject, ReplaySubject, AsyncSubject) that have additional features and behaviors, catering to specific use cases.

### REPLAYSUBJECT

`ReplaySubject` is a variant of the `Subject` that can remember and replay a specified number of emitted values to new subscribers. It caches and replays a portion of the emitted values, allowing late subscribers to receive those values. Let's explore how `ReplaySubject` works:

1. Creating a ReplaySubject:
You can create a ReplaySubject instance using the `ReplaySubject` class. It takes an optional parameter called `bufferSize`, which specifies the maximum number of values to be replayed.
    - Example:
        
        ```jsx
        import { ReplaySubject } from 'rxjs';
        
        const replaySubject = new ReplaySubject<number>(3);
        ```
        
    
    In this example, a new `ReplaySubject` instance is created to handle values of type `number`. The `bufferSize` is set to `3`, which means it will store and replay the last 3 emitted values.
    
2. Emitting values:
Similar to a regular Subject, you can emit values to the ReplaySubject using its `next` method. It will store the emitted values in its buffer for replay.
    - Example:
        
        ```jsx
        replaySubject.next(1);
        replaySubject.next(2);
        replaySubject.next(3);
        replaySubject.next(4);
        ```
        
    
    In this example, values `1`, `2`, `3`, and `4` are emitted to the `replaySubject` using its `next` method. Even though the buffer size is set to `3`, all four values will be stored in the buffer.
    
3. Subscribing to a ReplaySubject:
You can subscribe to a ReplaySubject to receive both new and replayed values. New subscribers will receive the buffered values immediately.
    - Example:
        
        ```jsx
        replaySubject.subscribe((value) => console.log(value));
        ```
        
    
    In this example, a subscription is created to the `replaySubject`, and a callback function is provided to handle the emitted values. The subscriber will receive both the buffered values (`1`, `2`, `3`) and any new values emitted in the future.
    
4. Replaying values:
The ReplaySubject automatically replays the buffered values to new subscribers when they subscribe. It will emit the buffered values immediately upon subscription.
    - Example:
        
        ```jsx
        // New subscriber
        replaySubject.subscribe((value) => console.log('New subscriber:', value));
        ```
        
    
    In this example, a new subscriber is created after values `1`, `2`, and `3` have been emitted. The new subscriber will immediately receive the buffered values (`1`, `2`, `3`) in addition to any new values emitted in the future.
    
- ReplaySubjects are useful in scenarios where you need to provide late subscribers with previously emitted values. They can be helpful in implementing caching mechanisms, handling historical data, or ensuring that subscribers receive an initial state of values.
- It's important to note that the `bufferSize` parameter determines the maximum number of values to be replayed. If the buffer size is set to `0`, no values will be replayed, and only new values will be emitted to subscribers.
- ReplaySubjects also have additional features, such as a `windowTime` parameter to control the time duration for which values are replayed, as well as other methods to inspect and manage the replay buffer.
- By using ReplaySubjects, you can create Observables that not only emit new values but also remember and replay a portion of the emitted values to new subscribers, enhancing the flexibility and functionality of your reactive applications.

### ASYNCSUBJECT

`AsyncSubject` is a variant of the `Subject` that only emits the last value emitted by the source Observable, and only when the source Observable completes. It will emit that last value to all its subscribers, even if there were no previous emissions. Let's explore how `AsyncSubject` works:

1. Creating an AsyncSubject:
You can create an AsyncSubject instance using the `AsyncSubject` class.
    - Example:
        
        ```jsx
        import { AsyncSubject } from 'rxjs';
        
        const asyncSubject = new AsyncSubject<number>();
        ```
        
    
    In this example, a new `AsyncSubject` instance is created to handle values of type `number`.
    
2. Emitting values:
Similar to a regular Subject, you can emit values to the AsyncSubject using its `next` method. However, the AsyncSubject will only remember the last value emitted.
    - Example:
        
        ```
        asyncSubject.next(1);
        asyncSubject.next(2);
        asyncSubject.next(3);
        asyncSubject.complete();
        
        ```
        
    
    In this example, values `1`, `2`, and `3` are emitted to the `asyncSubject` using its `next` method. The AsyncSubject only remembers the last emitted value (`3`).
    
3. Subscribing to an AsyncSubject:
You can subscribe to an AsyncSubject to receive its emitted value. However, the value will only be emitted when the AsyncSubject completes.
    - Example:
        
        ```
        asyncSubject.subscribe((value) => console.log(value));
        
        ```
        
    
    In this example, a subscription is created to the `asyncSubject`, and a callback function is provided to handle the emitted value. The subscriber will not receive any value until the AsyncSubject completes.
    
4. Completing an AsyncSubject:
You need to manually call the `complete` method on the AsyncSubject to trigger the emission of the last value to all subscribers.
    - Example:
        
        ```
        asyncSubject.complete();
        
        ```
        
    
    In this example, the `complete` method is called on the `asyncSubject`. This triggers the emission of the last value (`3`) to all subscribers.
    
    - AsyncSubjects are useful when you want to wait until the source Observable completes and only emit the final value to subscribers. They are often used in scenarios where you need to provide a result or a summary of values after a series of operations or asynchronous tasks have completed.
    - It's important to note that if the AsyncSubject does not complete, no value will be emitted to subscribers. Therefore, it's crucial to ensure that the source Observable completes for the AsyncSubject to emit its last value.
    - By using AsyncSubjects, you can create Observables that emit the final result of a sequence of values or asynchronous operations, allowing subscribers to receive the ultimate outcome when all the processing is complete.

### CONCAT & MERGE

In RxJS, both `concat` and `merge` are operators used to combine multiple Observables into a single Observable. However, they differ in how they handle the emissions and the order of the combined Observables. Let's explore each operator:

1. `concat` operator:
    - The `concat` operator combines multiple Observables by sequentially emitting values from each source Observable in the order they were provided.
    - It waits for each source Observable to complete before moving on to the next one.
    - The resulting Observable emits values in a serialized manner, maintaining the order of the source Observables.
    - Syntax:
        
        ```jsx
        concat<T>(...sources: (ObservableInput<T> | SchedulerLike | number)[]): Observable<T>
        ```
        
    
    Parameters:
    
    - `...sources`: Multiple Observables (or Promises, Iterables, or Arrays) to be concatenated.
    - Example usage:
        
        ```jsx
        import { of, concat } from 'rxjs';
        
        const source1$ = of(1, 2, 3);
        const source2$ = of(4, 5, 6);
        
        concat(source1$, source2$)
          .subscribe((value) => console.log(value));
        
        // Output: 1, 2, 3, 4, 5, 6
        ```
        
    
    In this example, the `concat` operator is used to combine `source1$` and `source2$` Observables. The resulting Observable emits values sequentially, first emitting all values from `source1$` and then emitting all values from `source2$`. The subscription logs the combined values (`1, 2, 3, 4, 5, 6`) to the console.
    
2. `merge` operator:
    - The `merge` operator combines multiple Observables by concurrently emitting values from all source Observables as they are emitted.
    - It does not wait for the completion of any source Observable and emits values in parallel.
    - The resulting Observable emits values in a non-serialized manner, depending on the order of emission from the source Observables.
    - Syntax:
        
        ```jsx
        merge<T>(...sources: (ObservableInput<T> | number | SchedulerLike)[]): Observable<T>
        ```
        
    
    Parameters:
    
    - `...sources`: Multiple Observables (or Promises, Iterables, or Arrays) to be merged.
    - Example usage:
        
        ```jsx
        import { of, merge } from 'rxjs';
        
        const source1$ = of(1, 2, 3);
        const source2$ = of(4, 5, 6);
        
        merge(source1$, source2$)
          .subscribe((value) => console.log(value));
        
        // Output: 1, 4, 2, 5, 3, 6 (Order may vary)
        ```
        
    
    In this example, the `merge` operator is used to combine `source1$` and `source2$` Observables. The resulting Observable emits values concurrently from both Observables as they are emitted. The subscription logs the merged values (`1, 4, 2, 5, 3, 6`), and the order may vary depending on the timing of emissions.
    
    - The choice between `concat` and `merge` depends on the desired behavior of combining Observables. If you want to maintain the order and serialize emissions, use `concat`. If you want concurrent emissions and don't require a specific order, use `merge`.
    - Both operators can handle a variable number of Observables and are useful for combining multiple streams of data, such as API requests or event streams, into a single Observable for further processing or subscription.
    - By leveraging the `concat` and `merge` operators, you can compose and combine multiple Observables in various ways to achieve complex data processing and coordination in your RxJS applications.

### MERGEMAP

`mergeMap` operator (also known as `flatMap`) is used to transform the values emitted by an Observable into inner Observables, and then merge and flatten their emissions into a single Observable stream. It concurrently subscribes to all inner Observables and emits their values as they are emitted, regardless of the order of emission. Let's explore how `mergeMap` works:

Syntax:

```jsx
mergeMap<T, R>(
  project: (value: T, index: number) => ObservableInput<R>,
  concurrent?: number
): OperatorFunction<T, R>
```

Parameters:

- `project`: A function that takes the emitted value from the source Observable and returns an inner Observable.
- `concurrent` (optional): The maximum number of inner Observables that can be subscribed to concurrently. By default, all inner Observables are subscribed to concurrently.

Example usage:

```jsx
import { of } from 'rxjs';
import { mergeMap } from 'rxjs/operators';

const source$ = of(1, 2, 3);

source$
  .pipe(
    mergeMap((value) => of(value * 2))
  )
  .subscribe((result) => console.log(result)); // Output: 2, 4, 6
```

- In this example, the `source$` Observable emits values `1`, `2`, and `3`. The `mergeMap` operator transforms each emitted value by multiplying it by 2 using the `of(value * 2)` Observable. The resulting Observable emits the flattened values `2`, `4`, and `6` as they are emitted from the inner Observables. The subscription then logs each flattened value to the console.
- The key aspect of `mergeMap` is that it concurrently merges and flattens the emissions of the inner Observables, emitting the values as they arrive, regardless of their order. This allows for concurrency and parallelism in handling the emissions, which can be useful for scenarios such as concurrent API requests or handling streams of events.
- It's worth noting that `mergeMap` does not guarantee the order of emissions. If you need to maintain the order, you can use `concatMap` or `exhaustMap` operators instead.
- By using the `mergeMap` operator, you can transform and flatten nested Observables, allowing you to handle concurrent streams of data and process them in a flexible and efficient manner

### CONCATMAP

`concatMap` operator is used to transform the values emitted by an Observable into inner Observables, and then concatenate and flatten their emissions in a serialized manner. It maintains the order of emission and ensures that each inner Observable completes before the next one starts. Let's explore how `concatMap` works:

- Syntax:
    
    ```jsx
    concatMap<T, R>(
      project: (value: T, index: number) => ObservableInput<R>,
      resultSelector?: (outerValue: T, innerValue: R, outerIndex: number, innerIndex: number) => any
    ): OperatorFunction<T, R>
    ```
    

Parameters:

- `project`: A function that takes the emitted value from the source Observable and returns an inner Observable.
- `resultSelector` (optional): A function that combines the values emitted by the source and inner Observables and returns the result.
- Example usage:
    
    ```jsx
    import { of } from 'rxjs';
    import { concatMap } from 'rxjs/operators';
    
    const source$ = of(1, 2, 3);
    
    source$
      .pipe(
        concatMap((value) => of(value * 2))
      )
      .subscribe((result) => console.log(result)); // Output: 2, 4, 6
    ```
    
- In this example, the `source$` Observable emits values `1`, `2`, and `3`. The `concatMap` operator transforms each emitted value by multiplying it by 2 using the `of(value * 2)` Observable. The resulting Observable emits the flattened values `2`, `4`, and `6` in a serialized manner, maintaining the order of the source Observable. The subscription then logs each flattened value to the console.
- The key aspect of `concatMap` is that it maintains the order of emission and ensures that the inner Observables are subscribed to and completed in a serialized manner. It waits for each inner Observable to complete before subscribing to the next one, effectively concatenating their emissions.
- It's important to note that the order of emission is preserved, but the overall stream is not blocked. Each inner Observable is subscribed to as soon as the previous one completes, allowing for efficient handling of asynchronous operations.
- By using the `concatMap` operator, you can transform and flatten nested Observables in a serialized manner, ensuring that each inner Observable completes before proceeding to the next one. This can be particularly useful for scenarios such as sequential API requests or ordered data transformations.

### SWITCHMAP

`switchMap` operator is used to transform the values emitted by an Observable into inner Observables, and then switch to a new inner Observable whenever a new value is emitted. It cancels the previous inner Observable subscription and only emits values from the most recent inner Observable. Let's explore how `switchMap` works:

- Syntax:
    
    ```jsx
    switchMap<T, R>(
      project: (value: T, index: number) => ObservableInput<R>,
      resultSelector?: (outerValue: T, innerValue: R, outerIndex: number, innerIndex: number) => any
    ): OperatorFunction<T, R>
    ```
    

Parameters:

- `project`: A function that takes the emitted value from the source Observable and returns an inner Observable.
- `resultSelector` (optional): A function that combines the values emitted by the source and inner Observables and returns the result.
- Example usage:
    
    ```jsx
    import { of, interval } from 'rxjs';
    import { switchMap } from 'rxjs/operators';
    
    const source$ = of(1, 2, 3);
    
    source$
      .pipe(
        switchMap((value) => interval(value * 1000).pipe(take(3)))
      )
      .subscribe((result) => console.log(result));
    
    // Output:
    // 0 (after 1 second)
    // 1 (after 2 seconds)
    // 2 (after 3 seconds)
    // 0 (after 2 seconds)
    // 1 (after 4 seconds)
    // 2 (after 6 seconds)
    // 0 (after 3 seconds)
    // 1 (after 6 seconds)
    // 2 (after 9 seconds)
    ```
    
- In this example, the `source$` Observable emits values `1`, `2`, and `3`. The `switchMap` operator transforms each emitted value by mapping it to an inner Observable created using `interval` and `take` operators. The inner Observable emits incremental values every `value * 1000` milliseconds (1 second for `1`, 2 seconds for `2`, and 3 seconds for `3`) and completes after emitting three values (`0`, `1`, `2`). The `switchMap` operator switches to a new inner Observable whenever a new value is emitted by the source Observable, canceling the previous inner Observable subscription.
- As a result, the subscription receives the values emitted by the most recent inner Observable and logs them to the console. The emitted values follow the pattern of the inner Observables, starting with `0` after the specified delay and incrementing every second until reaching `2`. The next inner Observable is subscribed to when a new value is emitted, and the process repeats.
- The `switchMap` operator is particularly useful when dealing with scenarios such as handling user input, where the previous ongoing operations become irrelevant once a new value is emitted. It allows you to switch to a new Observable stream based on the most recent value and handle the emissions in a dynamic and responsive manner.
- It's important to note that if the inner Observables have ongoing processes, switching to a new Observable will cancel the previous one. Therefore, any resources or side effects associated with the previous inner Observable may be disposed of.
- By utilizing the `switchMap` operator, you can transform and switch between inner Observables, handling dynamic data dependencies and ensuring that only the most recent inner Observable's values are emitted.

### EXHAUSTMAP

`exhaustMap` operator is used to transform the values emitted by an Observable into inner Observables. It ignores new values from the source Observable until the current inner Observable completes. It ensures that only one inner Observable is active at a time and prevents overlapping or concurrent emissions. Let's explore how `exhaustMap` works:

- Syntax:
    
    ```jsx
    exhaustMap<T, R>(
      project: (value: T, index: number) => ObservableInput<R>,
      resultSelector?: (outerValue: T, innerValue: R, outerIndex: number, innerIndex: number) => any
    ): OperatorFunction<T, R>
    ```
    

Parameters:

- `project`: A function that takes the emitted value from the source Observable and returns an inner Observable.
- `resultSelector` (optional): A function that combines the values emitted by the source and inner Observables and returns the result.
- Example usage:
    
    ```jsx
    import { of, interval } from 'rxjs';
    import { exhaustMap, take } from 'rxjs/operators';
    
    const source$ = of(1, 2, 3);
    
    source$
      .pipe(
        exhaustMap((value) => interval(value * 1000).pipe(take(3)))
      )
      .subscribe((result) => console.log(result));
    
    // Output:
    // 0 (after 1 second)
    // 1 (after 2 seconds)
    // 2 (after 3 seconds)
    // 0 (after 4 seconds)
    // 1 (after 5 seconds)
    // 2 (after 6 seconds)
    // 0 (after 7 seconds)
    // 1 (after 8 seconds)
    // 2 (after 9 seconds)
    ```
    
- In this example, the `source$` Observable emits values `1`, `2`, and `3`. The `exhaustMap` operator transforms each emitted value by mapping it to an inner Observable created using `interval` and `take` operators. The inner Observable emits incremental values every `value * 1000` milliseconds (1 second for `1`, 2 seconds for `2`, and 3 seconds for `3`) and completes after emitting three values (`0`, `1`, `2`). The `exhaustMap` operator ignores new values from the source Observable until the current inner Observable completes.
- As a result, the subscription receives the values emitted by the first inner Observable and logs them to the console. Only after the first inner Observable completes, the next value emitted by the source Observable triggers the subscription to the next inner Observable. The emitted values follow the pattern of the inner Observables, starting with `0` after the specified delay and incrementing every second until reaching `2`. The process repeats for each emitted value, but new values emitted by the source Observable are ignored until the current inner Observable completes.
- The `exhaustMap` operator is particularly useful when you want to prevent concurrent emissions and handle each value sequentially, ignoring new values until the current inner Observable is completed. It ensures that only one inner Observable is active at a time and avoids overlapping emissions.
- It's important to note that if the inner Observables have ongoing processes, emissions from the source Observable will be ignored until the current inner Observable completes.
- By utilizing the `exhaustMap` operator, you can transform and handle the emissions of inner Observables, ensuring that only one inner Observable is active at a time and preventing overlapping emissions for specific scenarios where concurrency is not desired.

### SHAREREPLAY

`shareReplay` operator is used to share and replay the emissions of an Observable to multiple subscribers. It allows multiple subscribers to receive the same set of emitted values, even if they subscribe at different times. Let's explore how `shareReplay` works:

- Syntax:
    
    ```jsx
    shareReplay<T>(configOrBufferSize?: number | ShareReplayConfig<T>): MonoTypeOperatorFunction<T>
    ```
    

Parameters:

- `configOrBufferSize` (optional): It can be a number representing the buffer size of values to replay or an object of type `ShareReplayConfig` that allows you to configure various options, such as buffer size, window time, and scheduler.
- Example usage:
    
    ```jsx
    import { interval } from 'rxjs';
    import { shareReplay } from 'rxjs/operators';
    
    const source$ = interval(1000).pipe(
      take(5),
      shareReplay(3)
    );
    
    source$.subscribe((value) => console.log('Subscriber 1:', value));
    
    setTimeout(() => {
      source$.subscribe((value) => console.log('Subscriber 2:', value));
    }, 3000);
    
    // Output:
    // Subscriber 1: 0
    // Subscriber 1: 1
    // Subscriber 1: 2
    // Subscriber 1: 3
    // Subscriber 1: 4
    // Subscriber 2: 2
    // Subscriber 2: 3
    // Subscriber 2: 4
    ```
    
- In this example, the `source$` Observable emits values from `0` to `4` every 1 second using the `interval` operator. The `shareReplay(3)` operator is applied to share and replay the emitted values with a buffer size of `3`.
- When the first subscriber (`Subscriber 1`) subscribes to `source$`, it receives values `0`, `1`, `2`, `3`, and `4` as they are emitted. Then, after a delay of 3 seconds, the second subscriber (`Subscriber 2`) subscribes to `source$` and receives the most recent buffered values (`2`, `3`, and `4`), replaying the last 3 emitted values.
- The `shareReplay` operator ensures that all subscribers receive the same set of values emitted by the source Observable, even if they subscribe at different times. It buffers a specified number of emitted values and replays them to new subscribers.
- The buffer size specifies how many values to keep in the replay buffer. If a new subscriber subscribes after the buffer is full, it will receive the buffered values, but if it subscribes before the buffer is full, it will receive both buffered values and subsequent emissions.
- By using the `shareReplay` operator, you can efficiently share and replay emitted values to multiple subscribers, providing them with consistent and synchronized data streams, which is useful in scenarios such as caching, sharing expensive computations, or sharing a single connection or data source among multiple observers.

### CATCHERROR & THROWERROR

`catchError` operator and the `throwError` function are used for error handling within Observables. They allow you to gracefully handle errors and propagate them through the Observable stream. Let's explore each of them:

1. `catchError` operator:
    - The `catchError` operator is used to catch errors emitted by an Observable and handle them gracefully, returning a new Observable or a fallback value.
    - It intercepts errors emitted by the source Observable and allows you to provide an alternative Observable or fallback value that will continue the stream.
    - It can be used in combination with other operators to handle errors in different ways, such as logging errors, retrying, or providing default values.
    - Syntax:
        
        ```
        catchError<T, O extends ObservableInput<any>>(
          selector: (err: any, caught: Observable<T>) => O
        ): OperatorFunction<T, T | ObservedValueOf<O>>
        
        ```
        
    
    Parameters:
    
    - `selector`: A function that takes the error and the source Observable as arguments and returns an Observable or fallback value.
    - Example usage:
        
        ```jsx
        import { throwError, of } from 'rxjs';
        import { catchError } from 'rxjs/operators';
        
        const source$ = throwError('Oops! An error occurred.');
        
        source$
          .pipe(
            catchError((error) => of(`Fallback value: ${error}`))
          )
          .subscribe(
            (value) => console.log(value),
            (error) => console.log('Caught error:', error)
          );
        
        // Output:
        // Fallback value: Oops! An error occurred.
        ```
        
    
    In this example, the `source$` Observable emits an error using the `throwError` function. The `catchError` operator intercepts the error, and the provided error handling function returns an Observable that emits a fallback value (`Fallback value: Oops! An error occurred.`). The subscription logs the emitted value to the console.
    
2. `throwError` function:
    - The `throwError` function is used to create an Observable that immediately emits an error notification.
    - It allows you to explicitly throw an error within an Observable stream.
    - Syntax:
        
        ```jsx
        throwError(error: any): Observable<never>
        ```
        
    
    Parameters:
    
    - `error`: The error object or error message to be emitted.
    - Example usage:
        
        ```jsx
        import { throwError } from 'rxjs';
        
        throwError('Oops! An error occurred.')
          .subscribe(
            () => console.log('This will not be reached.'),
            (error) => console.log('Caught error:', error)
          );
        
        // Output:
        // Caught error: Oops! An error occurred.
        ```
        
    
    In this example, the `throwError` function is used to create an Observable that emits an error immediately. The subscription catches the error and logs it to the console.
    
    - Both `catchError` and `throwError` are powerful tools for handling errors within Observable streams. They allow you to gracefully handle errors, recover from them, and control the flow of the Observable stream based on error conditions. They are commonly used for error handling, fallback mechanisms, retry strategies, or providing default values when errors occur.
    - By leveraging the `catchError` operator and the `throwError` function, you can enhance the robustness and reliability of your Observables by handling errors in a controlled and predictable manner.
    -